/**********************************************************************
**
** This file is part of ANGLECORE, an open-source software development
** kit for audio plugins.
**
** ANGLECORE is free software: you can redistribute it and / or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation, either version 3 of the License, or
** (at your option) any later version.
**
** ANGLECORE is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with ANGLECORE.If not, see <https://www.gnu.org/licenses/>.
**
** Copyright(C) 2020, ANGLE
**
**********************************************************************/

#pragma once

#include <memory>
#include <mutex>
#include <thread>
#include <chrono>
#include <utility>

#include "../audioworkflow/AudioWorkflow.h"
#include "../renderer/Renderer.h"
#include "MIDIBuffer.h"
#include "../audioworkflow/instrument/Instrument.h"
#include "../../config/RenderingConfig.h"
#include "../../config/AudioConfig.h"
#include "../../utility/StringView.h"
#include "../requestmanager/RequestManager.h"
#include "../requestmanager/requests/AddInstrumentRequest.h"

namespace ANGLECORE
{
    /**
    * \class Master Master.h
    * The Master orchestrates the rendering and the interaction with the end-user
    * requests. It should be the only entry point from outside when developping an
    * ANGLECORE-based application.
    */
    class Master
    {
    public:
        Master();

        /**
        * Sets the sample rate of the Master's AudioWorkflow.
        * @param[in] sampleRate The value of the sample rate, in Hz.
        */
        void setSampleRate(floating_type sampleRate);

        /**
        * Clears the Master's internal MIDIBuffer to prepare for rendering the next
        * audio block.
        */
        void clearMIDIBufferForNextAudioBlock();

        /**
        * Adds a new MIDIMessage at the end of the Master's internal MIDIBuffer, and
        * returns a reference to it. This method should only be called by the
        * real-time thread, right before calling the renderNextAudioBlock() method.
        */
        MIDIMessage& pushBackNewMIDIMessage();

        /**
        * Requests the Master to change one Parameter's value within the Instrument
        * positioned at the rack number \p rackNumber. Note that this does not mean
        * the request will take effect immediately: the Master will post the request
        * to the real-time thread to be taken care of in the next rendering session.
        * @param[in] rackNumber The Instrument's rack number. If this number is not
        *   valid, this method will have no effect.
        * @param[in] parameterIdentifier The Parameter's identifier. This can be
        *   passed in as a C string, as it will be implicitely converted into a
        *   StringView. If this parameter does not correspond to any parameter of
        *   the Instrument located at \p rackNumber, then this method will have no
        *   effect.
        * @param[in] newParameterValue The Parameter's new value.
        */
        void setParameterValue(unsigned short rackNumber, StringView parameterIdentifier, floating_type newParameterValue);

        /**
        * Renders the next audio block, using the internal MIDIBuffer as a source
        * of MIDI messages, and the provided parameters for computing and exporting
        * the output result.
        * @param[in] audioBlockToGenerate The memory location that will be used to
        *   output the audio data generated by the Renderer. This should correspond
        *   to an audio buffer of at least \p numChannels audio channels and \p
        *   numSamples audio samples.
        * @param[in] numChannels The number of channels available at the memory
        *   location \p audioBlockToGenerate. Note that ANGLECORE's engine may
        *   generate more channels than this number, and eventually merge them all
        *   to match that number.
        * @param[in] numSamples The number of samples to generate and write into
        *   \p audioBlockToGenerate.
        */
        void renderNextAudioBlock(float** audioBlockToGenerate, unsigned short numChannels, uint32_t numSamples);

        /**
        * Requests the Master to add an Instrument of the given type to the
        * AudioWorkflow. The type given as a template parameter must be a class that
        * inherits from the Instrument class.
        * 
        * Behind the scenes, this method creates an AddInstrumentRequest object and
        * passes it to an internal RequestManager that handles requests
        * asynchronously. The AddInstrumentRequest instructs to create and plug in
        * as many instances of the given class as they are voices in the
        * AudioWorkflow, so that each instance can play a separate note when
        * necessary.
        * 
        * This method is thread-safe: multiple requests to add an Instrument can be
        * submitted in parallel, as all requests are queued and safely processed one
        * after the other by the RequestManager.
        * 
        * Note that this method only makes a request and does not perform any
        * computation. It always returns instantly, and does not wait for the
        * AddInstrumentRequest to be executed and for all the instrument instances
        * to be added. Because of this asynchronous implementation, this method does
        * not provide any feedback on how the execution went. To retrieve such
        * information, create an AddInstrumentRequest::Listener and use the
        * alternative version of
        * addInstrument(AddInstrumentListener<InstrumentType>* listener) instead.
        */
        template<class InstrumentType>
        void addInstrument();

        /**
        * Requests the Master to add an Instrument of the given type to the
        * AudioWorkflow. The type given as a template parameter must be a class that
        * inherits from the Instrument class.
        * 
        * Behind the scenes, this method creates an AddInstrumentRequest object and
        * passes it to an internal RequestManager that handles requests
        * asynchronously. The AddInstrumentRequest instructs to create and plug in
        * as many instances of the given class as they are voices in the
        * AudioWorkflow, so that each instance can play a separate note when
        * necessary.
        * 
        * This method is thread-safe: multiple requests to add an Instrument can be
        * submitted in parallel, as all requests are queued and safely processed one
        * after the other by the RequestManager.
        *
        * Note that this method only makes a request and does not perform any
        * computation. It always returns instantly, and does not wait for the
        * AddInstrumentRequest to be executed and for all the instrument instances
        * to be added. The AddInstrumentRequest::Listener passed in parameter will
        * precisely be called once that point is reached to take over.
        * @param[in] listener The listener to call back when the request to add the
        *   new Instrument is executed. If this pointer is null, then no listener
        *   will be called and this method will have the same effect as its
        *   argument-less counterpart addInstrument().
        */
        template<class InstrumentType>
        void addInstrument(AddInstrumentListener<InstrumentType>* listener);

    protected:

        /**
        * \struct StopTracker Master.h
        * A StopTracker tracks a Voice's position while it stops playing and renders
        * its audio tail. This structure can store how close the Voice is to the end
        * of its tail in terms of remaining samples.
        */
        struct StopTracker
        {
            uint32_t stopDurationInSamples;
            uint32_t position;
        };

        /**
        * Renders the next audio block by splitting it into smaller audio chunks
        * that are all smaller than ANGLECORE's Stream fixed buffer size. This
        * method is the one that guarantees the Renderer only receives a valid
        * number of samples to render.
        * @param[in] audioBlockToGenerate The memory location that will be used to
        *   output the audio data generated by the Renderer. This should correspond
        *   to an audio buffer of at least \p numChannels audio channels and \p
        *   numSamples audio samples.
        * @param[in] numChannels The number of channels available at the memory
        *   location \p audioBlockToGenerate. Note that ANGLECORE's engine may
        *   generate more channels than this number, and eventually merge them all
        *   to match that number.
        * @param[in] numSamples The number of samples to generate and write into
        *   \p audioBlockToGenerate.
        * @param[in] startSample The position within the \p audioBlockToGenerate to
        *   start writing from.
        */
        void splitAndRenderNextAudioBlock(float** audioBlockToGenerate, unsigned short numChannels, uint32_t numSamples, uint32_t startSample);

        /** Processes the requests received in its internal queues. */
        void processRequests();

        /** Processes the given MIDIMessage. */
        void processMIDIMessage(const MIDIMessage& message);

        /**
        * Updates the Master's internal stop trackers corresponding to each Voice,
        * after \p numSamples were rendered. This method detects if it is necessary
        * to turn some voices off, and do so if needed.
        * @param[in] numSamples Number of samples that were just rendered, and that
        *   should be used to increment the stop trackers.
        */
        void updateStopTrackersAfterRendering(uint32_t numSamples);

    private:
        AudioWorkflow m_audioWorkflow;
        Renderer m_renderer;
        MIDIBuffer m_midiBuffer;
        RequestManager m_requestManager;
        bool m_voiceIsStopping[ANGLECORE_NUM_VOICES];
        StopTracker m_stopTrackers[ANGLECORE_NUM_VOICES];
    };

    template<class InstrumentType>
    void Master::addInstrument()
    {
        addInstrument<InstrumentType>(nullptr);
    }

    template<class InstrumentType>
    void Master::addInstrument(AddInstrumentListener<InstrumentType>* listener)
    {
        std::shared_ptr<AddInstrumentRequest<InstrumentType>> request = std::make_shared<AddInstrumentRequest<InstrumentType>>(m_audioWorkflow, m_renderer, listener);
        m_requestManager.postRequestAsynchronously(std::move(request));
    }
}